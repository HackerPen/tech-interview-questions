## Solution for counting bits


### Approach 1: Pop Count

**algorithm**

Solve the problem for one number at a time. We loop through the numbers in the range [0, n] and put the results in a list.

**implementation**

```java
public class Solution {
    private int popCount(int x) {
        int count;
        for (count = 0; x != 0; ++count) {
            x &= x - 1; // zeroing out the least significant nonzero bit
        }
        return count;
    }

    public int[] countBits(int n) {
        int[] ans = new int[n + 1];
        for (int x = 0; x <= n; ++x) {
            ans[x] = popCount(x);
        }
        return ans;
    }
}
```

```python
class Solution:
    def countBits(self, n: int) -> List[int]:

        def pop_count(x: int) -> int:
            count = 0
            while x != 0:
                x &= x - 1 # zeroing out the least significant nonzero bit
                count += 1
            return count

        ans = [0] * (n + 1)
        for x in range(n + 1):
            ans[x] = pop_count(x)

        return ans
```

**complexity**

Time complexity: `O(n⋅logn)`. For each integer xx, in the worst case, we need to perform O(logn) operations, since the number of bits in x equals logx+1 and all the bits can be equal to 1. However, on average, each bit will be set n/2 times, so for each integer x we will perform log(x)/2 operations, therefore, in total, it will cost O(n⋅log(n)/2) operations.

Space complexity: `O(1)`. Since the output array does not count towards the space complexity.

### Approach 2: Dynamic Programming + Most Significant Bit

**algorithm**

Use previous count results to generate the count for a new integer.

Suppose we have an integer:

`x = (1001011101) binary = (605) decimal`

and we already calculated and stored all the results of 0 to x-1

Then we know that x is differ by one bit with a number we already calculated:
​
`x' = (1011101) binary = (93) decimal`

They are different only in the most significant bit.

Let's exam the range [0, 3] in the binary form:

`(0) decimal = (0) binary`
`(1) decimal = (1) binary`
`(2) decimal = (10) binary`
`(3) decimal = (11) binary`

One can see that the binary form of 2 and 3 can be generated by adding 1 bit in front of 0 and 1. Thus, they are different only by 1 regarding pop count.
Similarly, we can generate the results for `[4, 7]` using `[0, 3]` as blueprints.

In general, we have the following transition function for popcount P(x):

`P(x + b) = P(x) + 1, b = 2^m > x`

With this transition function, we can then apply Dynamic Programming to generate all the pop counts starting from 0.

**implementation**

```java
public class Solution {
    public int[] countBits(int n) {
        int[] ans = new int[n + 1];
        int x = 0;
        int b = 1;

        // [0, b) is calculated
        while (b <= n) {
            // generate [b, 2b) or [b, n) from [0, b)
            while (x < b && x + b <= n) {
                ans[x + b] = ans[x] + 1;
                ++x;
            }                         
            x = 0; // reset x
            b <<= 1; // b = 2b
        }

        return ans;
    }
}
```

```python
class Solution:
    def countBits(self, n: int) -> List[int]:
        ans = [0] * (n + 1)
        x = 0
        b = 1

        # [0, b) is calculated
        while b <= n:
            # generate [b, 2b) or [b, n) from [0, b)
            while x < b and x + b <= n:
                ans[x + b] = ans[x] + 1
                x += 1
            x = 0 # reset x
            b <<= 1 # b = 2b

        return ans               
```

**complexity**

Time complexity: `O(n)`. For each integer x, in the range 1 to n, we need to perform a constant number of operations which does not depend on the number of bits in x.

Space complexity: `O(1)`. Since the output array does not count towards the space complexity.
